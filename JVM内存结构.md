# JVM内存结构

#### Java内存结构:

![](http://images2015.cnblogs.com/blog/331425/201606/331425-20160623115838891-809895495.png)

JVM内存结构主要有三大块: 堆内存, 方法区和栈.

#### 堆内存:

堆内存是JVM中最大的一块, 由年轻代和老年代组成,
年轻代内存又分成三部分: Eden空间, From Survivor空间, To Survivor空间, 默认分配比例 8:1:1

方法区存储类信息, 常量, 静态变量等数据, 是线程共享的区域,
栈分为java虚拟机和本地方法栈, 主要用于方法的执行

参数对应控制各区域的内存大小:
![](http://images2015.cnblogs.com/blog/331425/201606/331425-20160623115841031-564040608.png)

#### 控制参数:

    -Xms 设置堆得最小空间
    -Xmx 设置堆得最大空间
    -XX:NewSize 设置新生代最小空间大小
    -XX:MaxNexSize 设置新生代最大空间大小
    -XX:PermSize 设置永久代最小空间大小
    -XX:MaxPermSize 设置永久代最大空间大小
    -Xss 设置每个线程的堆栈大小

没有直接设置老年代的参数, 通过设置堆空间大小和新生代空间大小来间接控制

    老年代空间大小 = 堆空间大小 - 年轻代空间大小

JVM 和 系统调用之间的关系

![](http://images2015.cnblogs.com/blog/331425/201606/331425-20160623115845438-670228585.png)


#### Java堆:

Java堆是被所有线程共享的一块内存区域, 在虚拟机启动时创建. 此内存区域唯一的目的是存放对象实例, 几乎所有的对象实例都在这里分配内存.

Java堆是垃圾收集器管理的主要区域, 也被称为GC堆.  现在收集器的基本都是采用分代收集算法,  Java堆分为新生代和老年代; 再细致一点的有Eden空间, From Survivor空间, To Survivor空间等

如果堆中没有内存完成实例分配, 堆也无法再扩展时, 将会抛出OOM

#### 方法区(Method Area)

方法区与Java堆一样, 是各个线程共享的内存区域, 用于存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据.
别名 Non-Heap(非堆)

HotSpot虚拟机把GC分代收集扩展到方法区, 所以该区域也可以称为"永久代", 但和Java堆上的永久代并不等价.
该区域的内存回收主要针对常量池的回收和对类型的卸载, 当执行该回收的操作条件相当苛刻, 和永久代一样,基本上该区域的上的内容"永久存在"

当方法区无法满足内存分配需求时, 会抛出OOM


#### 程序计数器(Program Counter Register)

程序计数器是一块较小的内存空间, 它的作用可以看做是当前线程所执行的字节码的行号指示器. 在虚拟机的概念中, 字节码解释器工作就是通过改变程序计数器的值来选取下一条要执行的字节码指令, 分支, 循环, 跳转, 异常处理, 线程恢复等基础功能都需要依赖这个计数器来完成.

由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的.  因此为了线程切换后能恢复正常的执行位置, 每条线程都需要有一个独立的程序计数器, 各条线程之间计数器互不影响, 独立存储, 这类内存区域称为"线程私有"内存

如果线程正在执行的是一个Java方法, 这个计数器记录的是正在执行的虚拟机字节码指令的地址;
如果正在执行的是Native方法, 这个计数器的值为(Undefined);

此内存区域没有OOM的情况出现


#### JVM栈(JVM Stacks)

JVM栈也是线程私有的, 它的生命周期与线程相同.  当线程中方法被调用执行时, 会创建一个栈帧(StackFrame)用于存储局部变量变量表, 操作数栈, 动态链接,方法出口等信息. 每一个方法被调用直至执行完成的过程, 就对应着一个栈帧在虚拟机中从入栈到出栈的过程

局部变量表存放了编译期可知的各种基本类型(boolean, byte, char, short, int, float, long, double), 对象的引用(reference类型)和returnAddress类型(指向一条字节码指令的地址).

其中64位的long和double类型的数据会占用2个局部变量空间(slot), 其余的数据类型只占用1个. 局部变量表所需内存在编译是确定, 当进入一个方法时分配,空间是完全确定的, 在方法运行期不会改变

###### 两种异常:
如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出StackOverFlowError异常;
如果虚拟机可以动态扩展, 当扩展无法申请的到足够内存时,会抛出OOM异常;

#### 本地方法栈

本地方法栈与虚拟机栈功能相似, 区别在于虚拟机栈为虚拟机执行java方法服务, 本地方法栈是为虚拟机使用到Native方法服务的.

本地方法栈也会抛出两个异常 StackOverFlowError 和 OOM
